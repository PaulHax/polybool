"use strict";var e;Object.defineProperty(exports,"__esModule",{value:!0}),function(e){e[e.BeforeStart=0]="BeforeStart",e[e.EqualStart=1]="EqualStart",e[e.BetweenStartAndEnd=2]="BetweenStartAndEnd",e[e.EqualEnd=3]="EqualEnd",e[e.AfterEnd=4]="AfterEnd"}(e||(e={}));class t{pointsSame(e,t){return this.pointsSameX(e,t)&&this.pointsSameY(e,t)}pointsCompare(e,t){return this.pointsSameX(e,t)?this.pointsSameY(e,t)?0:e[1]<t[1]?-1:1:e[0]<t[0]?-1:1}}class s extends t{constructor(e=1e-10){super(),this.epsilon=e}pointAboveOrOnLine(e,t,s){const n=t[0],i=t[1],o=s[0],l=s[1],r=e[0];return(o-n)*(e[1]-i)-(l-i)*(r-n)>=-this.epsilon}pointBetween(e,t,s){const n=e[1]-t[1],i=s[0]-t[0],o=e[0]-t[0],l=s[1]-t[1],r=o*i+n*l;if(r<this.epsilon)return!1;return!(r-(i*i+l*l)>-this.epsilon)}pointsSameX(e,t){return Math.abs(e[0]-t[0])<this.epsilon}pointsSameY(e,t){return Math.abs(e[1]-t[1])<this.epsilon}pointsCollinear(e,t,s){const n=e[0]-t[0],i=e[1]-t[1],o=t[0]-s[0],l=t[1]-s[1];return Math.abs(n*l-o*i)<this.epsilon}linesIntersect(t,s,n,i){const o=s[0]-t[0],l=s[1]-t[1],r=i[0]-n[0],h=i[1]-n[1],a=o*h-l*r;if(Math.abs(a)<this.epsilon)return null;const d=t[0]-n[0],c=t[1]-n[1],u=(r*c-h*d)/a,g=(o*c-l*d)/a,p=t=>t<=-this.epsilon?e.BeforeStart:t<this.epsilon?e.EqualStart:t-1<=-this.epsilon?e.BetweenStartAndEnd:t-1<this.epsilon?e.EqualEnd:e.AfterEnd,m=[t[0]+u*o,t[1]+u*l];return{alongA:p(u),alongB:p(g),p:m}}}class n{constructor(){this.nodes=[]}remove(e){const t=this.nodes.indexOf(e);t>=0&&this.nodes.splice(t,1)}getIndex(e){return this.nodes.indexOf(e)}isEmpty(){return this.nodes.length<=0}getHead(){return this.nodes[0]}removeHead(){this.nodes.shift()}insertBefore(e,t){this.findTransition(e,t).insert(e)}findTransition(e,t){var s,n;let i=0,o=this.nodes.length;for(;i<o;){const s=i+o>>1;l=this.nodes[s],t(e)-t(l)>0?o=s:i=s+1}var l;return{before:i<=0?null:null!==(s=this.nodes[i-1])&&void 0!==s?s:null,after:null!==(n=this.nodes[i])&&void 0!==n?n:null,insert:e=>(this.nodes.splice(i,0,e),e)}}}class i{constructor(e,t,s,n){var i;this.otherFill=null,this.id=null!==(i=null==n?void 0:n.segmentId())&&void 0!==i?i:-1,this.start=e,this.end=t,this.myFill={above:s?s.myFill.above:null,below:s?s.myFill.below:null}}}class o{constructor(e,t,s,n){this.status=null,this.isStart=e,this.p=t,this.seg=s,this.primary=n}}class l{constructor(e,t,s=null){this.events=new n,this.status=new n,this.selfIntersection=e,this.geo=t,this.log=s}compareEvents(e,t,s,n,i,o){const l=this.geo.pointsCompare(t,i);return 0!==l?l:this.geo.pointsSame(s,o)?0:e!==n?e?1:-1:this.geo.pointAboveOrOnLine(s,n?i:o,n?o:i)?1:-1}addEvent(e){this.events.insertBefore(e,(t=>t===e?0:this.compareEvents(e.isStart,e.p,e.other.p,t.isStart,t.p,t.other.p)))}divideEvent(e,t){var s;const n=new i(t,e.seg.end,e.seg,this.log);return null===(s=this.log)||void 0===s||s.segmentChop(e.seg,t),this.events.remove(e.other),e.seg.end=t,e.other.p=t,this.addEvent(e.other),this.addSegment(n,e.primary)}newSegment(e,t){const s=this.geo.pointsCompare(e,t);return 0===s?null:s<0?new i(e,t,null,this.log):new i(t,e,null,this.log)}addSegment(e,t){const s=new o(!0,e.start,e,t),n=new o(!1,e.end,e,t);return s.other=n,n.other=s,this.addEvent(s),this.addEvent(n),s}addRegion(e){let t,s=e[e.length-1];for(let n=0;n<e.length;n++){t=s,s=e[n];const i=this.newSegment(t,s);i&&this.addSegment(i,!0)}}compareStatus(e,t){const s=e.seg.start,n=e.seg.end,i=t.seg.start,o=t.seg.end;return this.geo.pointsCollinear(s,i,o)?this.geo.pointsCollinear(n,i,o)||this.geo.pointAboveOrOnLine(n,i,o)?1:-1:this.geo.pointAboveOrOnLine(s,i,o)?1:-1}statusFindSurrounding(e){return this.status.findTransition(e,(t=>t===e?0:-this.compareStatus(e,t)))}checkIntersection(t,s){var n;const i=t.seg,o=s.seg,l=i.start,r=i.end,h=o.start,a=o.end;null===(n=this.log)||void 0===n||n.checkIntersection(i,o);const d=this.geo.linesIntersect(l,r,h,a);if(null===d){if(!this.geo.pointsCollinear(l,r,h))return null;if(this.geo.pointsSame(l,a)||this.geo.pointsSame(r,h))return null;const e=this.geo.pointsSame(l,h),n=this.geo.pointsSame(r,a);if(e&&n)return s;const i=!e&&this.geo.pointBetween(l,h,a),o=!n&&this.geo.pointBetween(r,h,a);if(e)return o?this.divideEvent(s,r):this.divideEvent(t,a),s;i&&(n||(o?this.divideEvent(s,r):this.divideEvent(t,a)),this.divideEvent(s,l))}else d.alongA===e.BetweenStartAndEnd&&(d.alongB===e.EqualStart?this.divideEvent(t,h):d.alongB===e.BetweenStartAndEnd?this.divideEvent(t,d.p):d.alongB===e.EqualEnd&&this.divideEvent(t,a)),d.alongB===e.BetweenStartAndEnd&&(d.alongA===e.EqualStart?this.divideEvent(s,l):d.alongA===e.BetweenStartAndEnd?this.divideEvent(s,d.p):d.alongA===e.EqualEnd&&this.divideEvent(s,r));return null}calculate(e,t){var s,n,i,o,l,r,h,a;const d=[];for(;!this.events.isEmpty();){const a=this.events.getHead();if(null===(s=this.log)||void 0===s||s.vert(a.p[0]),a.isStart){null===(n=this.log)||void 0===n||n.segmentNew(a.seg,a.primary);const s=this.statusFindSurrounding(a),h=s.before,d=s.after;null===(i=this.log)||void 0===i||i.tempStatus(a.seg,!!h&&h.seg,!!d&&d.seg);const c=()=>{if(h){const e=this.checkIntersection(a,h);if(e)return e}return d?this.checkIntersection(a,d):null},u=c();if(u){if(this.selfIntersection){let e;e=null===a.seg.myFill.below||a.seg.myFill.above!==a.seg.myFill.below,e&&(u.seg.myFill.above=!u.seg.myFill.above)}else u.seg.otherFill=a.seg.myFill;null===(o=this.log)||void 0===o||o.segmentUpdate(u.seg),this.events.remove(a.other),this.events.remove(a)}if(this.events.getHead()!==a){null===(l=this.log)||void 0===l||l.rewind(a.seg);continue}if(this.selfIntersection){let t;t=null===a.seg.myFill.below||a.seg.myFill.above!==a.seg.myFill.below,a.seg.myFill.below=d?d.seg.myFill.above:e,a.seg.myFill.above=t?!a.seg.myFill.below:a.seg.myFill.below}else if(null===a.seg.otherFill){let s;if(d)if(a.primary===d.primary){if(null===d.seg.otherFill)throw new Error("otherFill is null");s=d.seg.otherFill.above}else s=d.seg.myFill.above;else s=a.primary?t:e;a.seg.otherFill={above:s,below:s}}null===(r=this.log)||void 0===r||r.status(a.seg,!!h&&h.seg,!!d&&d.seg),a.other.status=s.insert(a)}else{const e=a.status;if(null===e)throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");const t=this.status.getIndex(e);if(t>0&&t<this.status.nodes.length-1){const e=this.status.nodes[t-1],s=this.status.nodes[t+1];this.checkIntersection(e,s)}if(null===(h=this.log)||void 0===h||h.statusRemove(e.seg),this.status.remove(e),!a.primary){if(!a.seg.otherFill)throw new Error("otherFill is null");const e=a.seg.myFill;a.seg.myFill=a.seg.otherFill,a.seg.otherFill=e}d.push(a.seg)}this.events.removeHead()}return null===(a=this.log)||void 0===a||a.done(),d}}function r(e,t,s){const n=[];for(const o of e){const e=(o.myFill.above?8:0)+(o.myFill.below?4:0)+(o.otherFill&&o.otherFill.above?2:0)+(o.otherFill&&o.otherFill.below?1:0);if(0!==t[e]){const l=new i(o.start,o.end,null,s);l.myFill.above=1===t[e],l.myFill.below=2===t[e],n.push(l)}}return null==s||s.selected(n),n}class h{static union(e,t){return r(e,[0,2,1,0,2,2,0,0,1,0,1,0,0,0,0,0],t)}static intersect(e,t){return r(e,[0,0,0,0,0,2,0,2,0,0,1,1,0,2,1,0],t)}static difference(e,t){return r(e,[0,0,0,0,2,0,2,0,1,1,0,0,0,1,2,0],t)}static differenceRev(e,t){return r(e,[0,2,1,0,0,0,1,1,0,2,0,2,0,0,0,0],t)}static xor(e,t){return r(e,[0,2,1,0,2,0,0,1,1,0,0,2,0,1,2,0],t)}}function a(e,t,s){const n=[],i=[];for(const o of e){const l=o.start,r=o.end;if(t.pointsSame(l,r)){console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");continue}null==s||s.chainStart(o);const h={index:0,matches_head:!1,matches_pt1:!1},a={index:0,matches_head:!1,matches_pt1:!1};let d=h;function c(e,t,s){return d&&(d.index=e,d.matches_head=t,d.matches_pt1=s),d===h?(d=a,!1):(d=null,!0)}for(let f=0;f<n.length;f++){const b=n[f],S=b[0],w=b[b.length-1];if(t.pointsSame(S,l)){if(c(f,!0,!0))break}else if(t.pointsSame(S,r)){if(c(f,!0,!1))break}else if(t.pointsSame(w,l)){if(c(f,!1,!0))break}else if(t.pointsSame(w,r)&&c(f,!1,!1))break}if(d===h){n.push([l,r]),null==s||s.chainNew(l,r);continue}if(d===a){null==s||s.chainMatch(h.index);const y=h.index,E=h.matches_pt1?r:l,x=h.matches_head,F=n[y];let _=x?F[0]:F[F.length-1];const B=x?F[1]:F[F.length-2],A=x?F[F.length-1]:F[0],I=x?F[F.length-2]:F[1];if(t.pointsCollinear(B,_,E)&&(x?(null==s||s.chainRemoveHead(h.index,E),F.shift()):(null==s||s.chainRemoveTail(h.index,E),F.pop()),_=B),t.pointsSame(A,E)){n.splice(y,1),t.pointsCollinear(I,A,_)&&(x?(null==s||s.chainRemoveTail(h.index,_),F.pop()):(null==s||s.chainRemoveHead(h.index,_),F.shift())),null==s||s.chainClose(h.index),i.push(F);continue}x?(null==s||s.chainAddHead(h.index,E),F.unshift(E)):(null==s||s.chainAddTail(h.index,E),F.push(E));continue}function u(e){null==s||s.chainReverse(e),n[e].reverse()}function g(e,i){const o=n[e],l=n[i];let r=o[o.length-1];const h=o[o.length-2],a=l[0],d=l[1];t.pointsCollinear(h,r,a)&&(null==s||s.chainRemoveTail(e,r),o.pop(),r=h),t.pointsCollinear(r,a,d)&&(null==s||s.chainRemoveHead(i,a),l.shift()),null==s||s.chainJoin(e,i),n[e]=o.concat(l),n.splice(i,1)}const p=h.index,m=a.index;null==s||s.chainConnect(p,m);const v=n[p].length<n[m].length;h.matches_head?a.matches_head?v?(u(p),g(p,m)):(u(m),g(m,p)):g(m,p):a.matches_head?g(p,m):v?(u(p),g(m,p)):(u(m),g(p,m))}return i}class d{constructor(){this.list=[],this.nextSegmentId=0,this.curVert=NaN}push(e,t){this.list.push({type:e,data:JSON.parse(JSON.stringify(t))})}segmentId(){return this.nextSegmentId++}checkIntersection(e,t){this.push("check",{seg1:e,seg2:t})}segmentChop(e,t){this.push("div_seg",{seg:e,p:t}),this.push("chop",{seg:e,p:t})}statusRemove(e){this.push("pop_seg",{seg:e})}segmentUpdate(e){this.push("seg_update",{seg:e})}segmentNew(e,t){this.push("new_seg",{seg:e,primary:t})}tempStatus(e,t,s){this.push("temp_status",{seg:e,above:t,below:s})}rewind(e){this.push("rewind",{seg:e})}status(e,t,s){this.push("status",{seg:e,above:t,below:s})}vert(e){e!==this.curVert&&(this.push("vert",{x:e}),this.curVert=e)}selected(e){this.push("selected",{segs:e})}chainStart(e){this.push("chain_start",{seg:e})}chainRemoveHead(e,t){this.push("chain_rem_head",{index:e,p:t})}chainRemoveTail(e,t){this.push("chain_rem_tail",{index:e,p:t})}chainNew(e,t){this.push("chain_new",{p1:e,p2:t})}chainMatch(e){this.push("chain_match",{index:e})}chainClose(e){this.push("chain_close",{index:e})}chainAddHead(e,t){this.push("chain_add_head",{index:e,p:t})}chainAddTail(e,t){this.push("chain_add_tail",{index:e,p:t})}chainConnect(e,t){this.push("chain_con",{index1:e,index2:t})}chainReverse(e){this.push("chain_rev",{index:e})}chainJoin(e,t){this.push("chain_join",{index1:e,index2:t})}done(){this.push("done",null)}}class c{constructor(e){this.log=null,this.geo=e}buildLog(e){var t;return this.log=e?new d:null,null===(t=this.log)||void 0===t?void 0:t.list}segments(e){const t=new l(!0,this.geo,this.log);for(const s of e.regions)t.addRegion(s);return{segments:t.calculate(e.inverted,!1),inverted:e.inverted}}combine(e,t){const s=new l(!1,this.geo,this.log);for(const t of e.segments)s.addSegment(new i(t.start,t.end,t,this.log),!0);for(const e of t.segments)s.addSegment(new i(e.start,e.end,e,this.log),!1);return{combined:s.calculate(e.inverted,t.inverted),inverted1:e.inverted,inverted2:t.inverted}}selectUnion(e){return{segments:h.union(e.combined,this.log),inverted:e.inverted1||e.inverted2}}selectIntersect(e){return{segments:h.intersect(e.combined,this.log),inverted:e.inverted1&&e.inverted2}}selectDifference(e){return{segments:h.difference(e.combined,this.log),inverted:e.inverted1&&!e.inverted2}}selectDifferenceRev(e){return{segments:h.differenceRev(e.combined,this.log),inverted:!e.inverted1&&e.inverted2}}selectXor(e){return{segments:h.xor(e.combined,this.log),inverted:e.inverted1!==e.inverted2}}polygon(e){return{regions:a(e.segments,this.geo,this.log),inverted:e.inverted}}union(e,t){const s=this.segments(e),n=this.segments(t),i=this.combine(s,n),o=this.selectUnion(i);return this.polygon(o)}intersect(e,t){const s=this.segments(e),n=this.segments(t),i=this.combine(s,n),o=this.selectIntersect(i);return this.polygon(o)}difference(e,t){const s=this.segments(e),n=this.segments(t),i=this.combine(s,n),o=this.selectDifference(i);return this.polygon(o)}differenceRev(e,t){const s=this.segments(e),n=this.segments(t),i=this.combine(s,n),o=this.selectDifferenceRev(i);return this.polygon(o)}xor(e,t){const s=this.segments(e),n=this.segments(t),i=this.combine(s,n),o=this.selectXor(i);return this.polygon(o)}}const u=new c(new s);exports.BuildLog=d,exports.GeometryEpsilon=s,exports.Intersecter=l,exports.PolyBool=c,exports.Segment=i,exports.SegmentChainer=a,exports.SegmentSelector=h,exports.default=u;
