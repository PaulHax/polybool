var e;!function(e){e[e.BeforeStart=0]="BeforeStart",e[e.EqualStart=1]="EqualStart",e[e.BetweenStartAndEnd=2]="BetweenStartAndEnd",e[e.EqualEnd=3]="EqualEnd",e[e.AfterEnd=4]="AfterEnd"}(e||(e={}));class t{pointsSame(e,t){return this.pointsSameX(e,t)&&this.pointsSameY(e,t)}pointsCompare(e,t){return this.pointsSameX(e,t)?this.pointsSameY(e,t)?0:e[1]<t[1]?-1:1:e[0]<t[0]?-1:1}}class n extends t{constructor(e=1e-10){super(),this.epsilon=e}pointAboveOrOnLine(e,t,n){const s=t[0],i=t[1],o=n[0],r=n[1],l=e[0];return(o-s)*(e[1]-i)-(r-i)*(l-s)>=-this.epsilon}pointBetween(e,t,n){const s=e[1]-t[1],i=n[0]-t[0],o=e[0]-t[0],r=n[1]-t[1],l=o*i+s*r;if(l<this.epsilon)return!1;return!(l-(i*i+r*r)>-this.epsilon)}pointsSameX(e,t){return Math.abs(e[0]-t[0])<this.epsilon}pointsSameY(e,t){return Math.abs(e[1]-t[1])<this.epsilon}pointsCollinear(e,t,n){const s=e[0]-t[0],i=e[1]-t[1],o=t[0]-n[0],r=t[1]-n[1];return Math.abs(s*r-o*i)<this.epsilon}linesIntersect(t,n,s,i){const o=n[0]-t[0],r=n[1]-t[1],l=i[0]-s[0],h=i[1]-s[1],a=o*h-r*l;if(Math.abs(a)<this.epsilon)return null;const d=t[0]-s[0],c=t[1]-s[1],u=(l*c-h*d)/a,g=(o*c-r*d)/a,m=t=>t<=-this.epsilon?e.BeforeStart:t<this.epsilon?e.EqualStart:t-1<=-this.epsilon?e.BetweenStartAndEnd:t-1<this.epsilon?e.EqualEnd:e.AfterEnd,p=[t[0]+u*o,t[1]+u*r];return{alongA:m(u),alongB:m(g),p:p}}}class s{constructor(){this.nodes=[]}exists(e){return this.nodes.includes(e)}remove(e){const t=this.nodes.indexOf(e);t>=0&&this.nodes.splice(t,1)}getIndex(e){return this.nodes.indexOf(e)}isEmpty(){return this.nodes.length<=0}getHead(){return this.nodes[0]}removeHead(){this.nodes.shift()}insertBefore(e,t){this.findTransition(e,t).insert(e)}findTransition(e,t){var n,s;let i=0,o=this.nodes.length;for(;i<o;){const n=i+o>>1;r=this.nodes[n],t(e)-t(r)>0?o=n:i=n+1}var r;return{before:i<=0?null:null!==(n=this.nodes[i-1])&&void 0!==n?n:null,after:null!==(s=this.nodes[i])&&void 0!==s?s:null,insert:e=>(this.nodes.splice(i,0,e),e)}}}class i{constructor(e,t,n){this.otherFill=null,this.start=e,this.end=t,this.myFill={above:n?n.myFill.above:null,below:n?n.myFill.below:null}}}class o{constructor(e,t,n,s){this.status=null,this.isStart=e,this.p=t,this.seg=n,this.primary=s}}class r{constructor(e,t){this.events=new s,this.status=new s,this.selfIntersection=e,this.geo=t}compareEvents(e,t,n,s,i,o){const r=this.geo.pointsCompare(t,i);return 0!==r?r:this.geo.pointsSame(n,o)?0:e!==s?e?1:-1:this.geo.pointAboveOrOnLine(n,s?i:o,s?o:i)?1:-1}addEvent(e){this.events.insertBefore(e,(t=>t===e?0:this.compareEvents(e.isStart,e.p,e.other.p,t.isStart,t.p,t.other.p)))}divideEvent(e,t){const n=new i(t,e.seg.end,e.seg);return this.events.remove(e.other),e.seg.end=t,e.other.p=t,this.addEvent(e.other),this.addSegment(n,e.primary)}newSegment(e,t){const n=this.geo.pointsCompare(e,t);return 0===n?null:n<0?new i(e,t):new i(t,e)}addSegment(e,t){const n=new o(!0,e.start,e,t),s=new o(!1,e.end,e,t);return n.other=s,s.other=n,this.addEvent(n),this.addEvent(s),n}addRegion(e){let t,n=e[e.length-1];for(let s=0;s<e.length;s++){t=n,n=e[s];const i=this.newSegment(t,n);i&&this.addSegment(i,!0)}}compareStatus(e,t){const n=e.seg.start,s=e.seg.end,i=t.seg.start,o=t.seg.end;return this.geo.pointsCollinear(n,i,o)?this.geo.pointsCollinear(s,i,o)||this.geo.pointAboveOrOnLine(s,i,o)?1:-1:this.geo.pointAboveOrOnLine(n,i,o)?1:-1}statusFindSurrounding(e){return this.status.findTransition(e,(t=>t===e?0:-this.compareStatus(e,t)))}checkIntersection(t,n){const s=t.seg,i=n.seg,o=s.start,r=s.end,l=i.start,h=i.end,a=this.geo.linesIntersect(o,r,l,h);if(null===a){if(!this.geo.pointsCollinear(o,r,l))return null;if(this.geo.pointsSame(o,h)||this.geo.pointsSame(r,l))return null;const e=this.geo.pointsSame(o,l),s=this.geo.pointsSame(r,h);if(e&&s)return n;const i=!e&&this.geo.pointBetween(o,l,h),a=!s&&this.geo.pointBetween(r,l,h);if(e)return a?this.divideEvent(n,r):this.divideEvent(t,h),n;i&&(s||(a?this.divideEvent(n,r):this.divideEvent(t,h)),this.divideEvent(n,o))}else a.alongA===e.BetweenStartAndEnd&&(a.alongB===e.EqualStart?this.divideEvent(t,l):a.alongB===e.BetweenStartAndEnd?this.divideEvent(t,a.p):a.alongB===e.EqualEnd&&this.divideEvent(t,h)),a.alongB===e.BetweenStartAndEnd&&(a.alongA===e.EqualStart?this.divideEvent(n,o):a.alongA===e.BetweenStartAndEnd?this.divideEvent(n,a.p):a.alongA===e.EqualEnd&&this.divideEvent(n,r));return null}calculate(e,t){const n=[];for(;!this.events.isEmpty();){const s=this.events.getHead();if(s.isStart){const n=this.statusFindSurrounding(s),i=n.before,o=n.after,r=()=>{if(i){const e=this.checkIntersection(s,i);if(e)return e}return o?this.checkIntersection(s,o):null},l=r();if(l){if(this.selfIntersection){let e;e=null===s.seg.myFill.below||s.seg.myFill.above!==s.seg.myFill.below,e&&(l.seg.myFill.above=!l.seg.myFill.above)}else l.seg.otherFill=s.seg.myFill;this.events.remove(s.other),this.events.remove(s)}if(this.events.getHead()!==s)continue;if(this.selfIntersection){let t;t=null===s.seg.myFill.below||s.seg.myFill.above!==s.seg.myFill.below,s.seg.myFill.below=o?o.seg.myFill.above:e,s.seg.myFill.above=t?!s.seg.myFill.below:s.seg.myFill.below}else if(null===s.seg.otherFill){let n;if(o)if(s.primary===o.primary){if(null===o.seg.otherFill)throw new Error("otherFill is null");n=o.seg.otherFill.above}else n=o.seg.myFill.above;else n=s.primary?t:e;s.seg.otherFill={above:n,below:n}}s.other.status=n.insert(s)}else{const e=s.status;if(null===e)throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");const t=this.status.getIndex(e);if(t>0&&t<this.status.nodes.length-1){const e=this.status.nodes[t-1],n=this.status.nodes[t+1];this.checkIntersection(e,n)}if(this.status.remove(e),!s.primary){if(!s.seg.otherFill)throw new Error("otherFill is null");const e=s.seg.myFill;s.seg.myFill=s.seg.otherFill,s.seg.otherFill=e}n.push(s.seg)}this.events.removeHead()}return n}}function l(e,t){const n=[];for(const s of e){const e=(s.myFill.above?8:0)+(s.myFill.below?4:0)+(s.otherFill&&s.otherFill.above?2:0)+(s.otherFill&&s.otherFill.below?1:0);if(0!==t[e]){const o=new i(s.start,s.end);o.myFill.above=1===t[e],o.myFill.below=2===t[e],n.push(o)}}return n}class h{static union(e){return l(e,[0,2,1,0,2,2,0,0,1,0,1,0,0,0,0,0])}static intersect(e){return l(e,[0,0,0,0,0,2,0,2,0,0,1,1,0,2,1,0])}static difference(e){return l(e,[0,0,0,0,2,0,2,0,1,1,0,0,0,1,2,0])}static differenceRev(e){return l(e,[0,2,1,0,0,0,1,1,0,2,0,2,0,0,0,0])}static xor(e){return l(e,[0,2,1,0,2,0,0,1,1,0,0,2,0,1,2,0])}}function a(e,t){const n=[],s=[];for(const i of e){const o=i.start,r=i.end;if(t.pointsSame(o,r)){console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");continue}const l={index:0,matches_head:!1,matches_pt1:!1},h={index:0,matches_head:!1,matches_pt1:!1};let a=l;function d(e,t,n){return a.index=e,a.matches_head=t,a.matches_pt1=n,a!==l||(a=h,!1)}for(let v=0;v<n.length;v++){const f=n[v],b=f[0],E=f[f.length-1];if(t.pointsSame(b,o)){if(d(v,!0,!0))break}else if(t.pointsSame(b,r)){if(d(v,!0,!1))break}else if(t.pointsSame(E,o)){if(d(v,!1,!0))break}else if(t.pointsSame(E,r)&&d(v,!1,!1))break}if(a===l){n.push([o,r]);continue}if(a===h){const S=l.index,w=l.matches_pt1?r:o,y=l.matches_head,F=n[S];let B=y?F[0]:F[F.length-1];const A=y?F[1]:F[F.length-2],x=y?F[F.length-1]:F[0],I=y?F[F.length-2]:F[1];if(t.pointsCollinear(A,B,w)&&(y?F.shift():F.pop(),B=A),t.pointsSame(x,w)){n.splice(S,1),t.pointsCollinear(I,x,B)&&(y?F.pop():F.shift()),s.push(F);continue}y?F.unshift(w):F.push(w);continue}function c(e){n[e].reverse()}function u(e,s){const i=n[e],o=n[s];let r=i[i.length-1];const l=i[i.length-2],h=o[0],a=o[1];t.pointsCollinear(l,r,h)&&(i.pop(),r=l),t.pointsCollinear(r,h,a)&&o.shift(),n[e]=i.concat(o),n.splice(s,1)}const g=l.index,m=h.index,p=n[g].length<n[m].length;l.matches_head?h.matches_head?p?(c(g),u(g,m)):(c(m),u(m,g)):u(m,g):h.matches_head?u(g,m):p?(c(g),u(m,g)):(c(m),u(g,m))}return s}class d{constructor(e){this.geo=e}segments(e){const t=new r(!0,this.geo);for(const n of e.regions)t.addRegion(n);return{segments:t.calculate(e.inverted,!1),inverted:e.inverted}}combine(e,t){const n=new r(!1,this.geo);for(const t of e.segments)n.addSegment(new i(t.start,t.end,t),!0);for(const e of t.segments)n.addSegment(new i(e.start,e.end,e),!1);return{combined:n.calculate(e.inverted,t.inverted),inverted1:e.inverted,inverted2:t.inverted}}selectUnion(e){return{segments:h.union(e.combined),inverted:e.inverted1||e.inverted2}}selectIntersect(e){return{segments:h.intersect(e.combined),inverted:e.inverted1&&e.inverted2}}selectDifference(e){return{segments:h.difference(e.combined),inverted:e.inverted1&&!e.inverted2}}selectDifferenceRev(e){return{segments:h.differenceRev(e.combined),inverted:!e.inverted1&&e.inverted2}}selectXor(e){return{segments:h.xor(e.combined),inverted:e.inverted1!==e.inverted2}}polygon(e){return{regions:a(e.segments,this.geo),inverted:e.inverted}}union(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),o=this.selectUnion(i);return this.polygon(o)}intersect(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),o=this.selectIntersect(i);return this.polygon(o)}difference(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),o=this.selectDifference(i);return this.polygon(o)}differenceRev(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),o=this.selectDifferenceRev(i);return this.polygon(o)}xor(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),o=this.selectXor(i);return this.polygon(o)}}const c=new d(new n);export{n as GeometryEpsilon,r as Intersecter,d as PolyBool,i as Segment,a as SegmentChainer,h as SegmentSelector,c as default};
