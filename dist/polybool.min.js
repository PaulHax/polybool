var e;!function(e){e[e.BeforeStart=0]="BeforeStart",e[e.EqualStart=1]="EqualStart",e[e.BetweenStartAndEnd=2]="BetweenStartAndEnd",e[e.EqualEnd=3]="EqualEnd",e[e.AfterEnd=4]="AfterEnd"}(e||(e={}));class t{pointsSame(e,t){return this.pointsSameX(e,t)&&this.pointsSameY(e,t)}pointsCompare(e,t){return this.pointsSameX(e,t)?this.pointsSameY(e,t)?0:e[1]<t[1]?-1:1:e[0]<t[0]?-1:1}}class n extends t{constructor(e=1e-10){super(),this.epsilon=e}pointAboveOrOnLine(e,t,n){const s=t[0],i=t[1],o=n[0],l=n[1],r=e[0];return(o-s)*(e[1]-i)-(l-i)*(r-s)>=-this.epsilon}pointBetween(e,t,n){const s=e[1]-t[1],i=n[0]-t[0],o=e[0]-t[0],l=n[1]-t[1],r=o*i+s*l;if(r<this.epsilon)return!1;return!(r-(i*i+l*l)>-this.epsilon)}pointsSameX(e,t){return Math.abs(e[0]-t[0])<this.epsilon}pointsSameY(e,t){return Math.abs(e[1]-t[1])<this.epsilon}pointsCollinear(e,t,n){const s=e[0]-t[0],i=e[1]-t[1],o=t[0]-n[0],l=t[1]-n[1];return Math.abs(s*l-o*i)<this.epsilon}linesIntersect(t,n,s,i){const o=n[0]-t[0],l=n[1]-t[1],r=i[0]-s[0],h=i[1]-s[1],a=o*h-l*r;if(Math.abs(a)<this.epsilon)return null;const d=t[0]-s[0],c=t[1]-s[1],u=(r*c-h*d)/a,g=(o*c-l*d)/a,p=t=>t<=-this.epsilon?e.BeforeStart:t<this.epsilon?e.EqualStart:t-1<=-this.epsilon?e.BetweenStartAndEnd:t-1<this.epsilon?e.EqualEnd:e.AfterEnd,m=[t[0]+u*o,t[1]+u*l];return{alongA:p(u),alongB:p(g),p:m}}}class s{constructor(){this.nodes=[]}remove(e){const t=this.nodes.indexOf(e);t>=0&&this.nodes.splice(t,1)}getIndex(e){return this.nodes.indexOf(e)}isEmpty(){return this.nodes.length<=0}getHead(){return this.nodes[0]}removeHead(){this.nodes.shift()}insertBefore(e,t){this.findTransition(e,t).insert(e)}findTransition(e,t){var n,s;let i=0,o=this.nodes.length;for(;i<o;){const n=i+o>>1;l=this.nodes[n],t(e)-t(l)>0?o=n:i=n+1}var l;return{before:i<=0?null:null!==(n=this.nodes[i-1])&&void 0!==n?n:null,after:null!==(s=this.nodes[i])&&void 0!==s?s:null,insert:e=>(this.nodes.splice(i,0,e),e)}}}class i{constructor(e,t,n,s){var i;this.otherFill=null,this.id=null!==(i=null==s?void 0:s.segmentId())&&void 0!==i?i:-1,this.start=e,this.end=t,this.myFill={above:n?n.myFill.above:null,below:n?n.myFill.below:null}}}class o{constructor(e,t,n,s){this.status=null,this.isStart=e,this.p=t,this.seg=n,this.primary=s}}class l{constructor(e,t,n=null){this.events=new s,this.status=new s,this.selfIntersection=e,this.geo=t,this.log=n}compareEvents(e,t,n,s,i,o){const l=this.geo.pointsCompare(t,i);return 0!==l?l:this.geo.pointsSame(n,o)?0:e!==s?e?1:-1:this.geo.pointAboveOrOnLine(n,s?i:o,s?o:i)?1:-1}addEvent(e){this.events.insertBefore(e,(t=>t===e?0:this.compareEvents(e.isStart,e.p,e.other.p,t.isStart,t.p,t.other.p)))}divideEvent(e,t){var n;const s=new i(t,e.seg.end,e.seg,this.log);return null===(n=this.log)||void 0===n||n.segmentChop(e.seg,t),this.events.remove(e.other),e.seg.end=t,e.other.p=t,this.addEvent(e.other),this.addSegment(s,e.primary)}newSegment(e,t){const n=this.geo.pointsCompare(e,t);return 0===n?null:n<0?new i(e,t,null,this.log):new i(t,e,null,this.log)}addSegment(e,t){const n=new o(!0,e.start,e,t),s=new o(!1,e.end,e,t);return n.other=s,s.other=n,this.addEvent(n),this.addEvent(s),n}addRegion(e){let t,n=e[e.length-1];for(let s=0;s<e.length;s++){t=n,n=e[s];const i=this.newSegment(t,n);i&&this.addSegment(i,!0)}}compareStatus(e,t){const n=e.seg.start,s=e.seg.end,i=t.seg.start,o=t.seg.end;return this.geo.pointsCollinear(n,i,o)?this.geo.pointsCollinear(s,i,o)||this.geo.pointAboveOrOnLine(s,i,o)?1:-1:this.geo.pointAboveOrOnLine(n,i,o)?1:-1}statusFindSurrounding(e){return this.status.findTransition(e,(t=>t===e?0:-this.compareStatus(e,t)))}checkIntersection(t,n){var s;const i=t.seg,o=n.seg,l=i.start,r=i.end,h=o.start,a=o.end;null===(s=this.log)||void 0===s||s.checkIntersection(i,o);const d=this.geo.linesIntersect(l,r,h,a);if(null===d){if(!this.geo.pointsCollinear(l,r,h))return null;if(this.geo.pointsSame(l,a)||this.geo.pointsSame(r,h))return null;const e=this.geo.pointsSame(l,h),s=this.geo.pointsSame(r,a);if(e&&s)return n;const i=!e&&this.geo.pointBetween(l,h,a),o=!s&&this.geo.pointBetween(r,h,a);if(e)return o?this.divideEvent(n,r):this.divideEvent(t,a),n;i&&(s||(o?this.divideEvent(n,r):this.divideEvent(t,a)),this.divideEvent(n,l))}else d.alongA===e.BetweenStartAndEnd&&(d.alongB===e.EqualStart?this.divideEvent(t,h):d.alongB===e.BetweenStartAndEnd?this.divideEvent(t,d.p):d.alongB===e.EqualEnd&&this.divideEvent(t,a)),d.alongB===e.BetweenStartAndEnd&&(d.alongA===e.EqualStart?this.divideEvent(n,l):d.alongA===e.BetweenStartAndEnd?this.divideEvent(n,d.p):d.alongA===e.EqualEnd&&this.divideEvent(n,r));return null}calculate(e,t){var n,s,i,o,l,r,h,a;const d=[];for(;!this.events.isEmpty();){const a=this.events.getHead();if(null===(n=this.log)||void 0===n||n.vert(a.p[0]),a.isStart){null===(s=this.log)||void 0===s||s.segmentNew(a.seg,a.primary);const n=this.statusFindSurrounding(a),h=n.before,d=n.after;null===(i=this.log)||void 0===i||i.tempStatus(a.seg,!!h&&h.seg,!!d&&d.seg);const c=()=>{if(h){const e=this.checkIntersection(a,h);if(e)return e}return d?this.checkIntersection(a,d):null},u=c();if(u){if(this.selfIntersection){let e;e=null===a.seg.myFill.below||a.seg.myFill.above!==a.seg.myFill.below,e&&(u.seg.myFill.above=!u.seg.myFill.above)}else u.seg.otherFill=a.seg.myFill;null===(o=this.log)||void 0===o||o.segmentUpdate(u.seg),this.events.remove(a.other),this.events.remove(a)}if(this.events.getHead()!==a){null===(l=this.log)||void 0===l||l.rewind(a.seg);continue}if(this.selfIntersection){let t;t=null===a.seg.myFill.below||a.seg.myFill.above!==a.seg.myFill.below,a.seg.myFill.below=d?d.seg.myFill.above:e,a.seg.myFill.above=t?!a.seg.myFill.below:a.seg.myFill.below}else if(null===a.seg.otherFill){let n;if(d)if(a.primary===d.primary){if(null===d.seg.otherFill)throw new Error("otherFill is null");n=d.seg.otherFill.above}else n=d.seg.myFill.above;else n=a.primary?t:e;a.seg.otherFill={above:n,below:n}}null===(r=this.log)||void 0===r||r.status(a.seg,!!h&&h.seg,!!d&&d.seg),a.other.status=n.insert(a)}else{const e=a.status;if(null===e)throw new Error("PolyBool: Zero-length segment detected; your epsilon is probably too small or too large");const t=this.status.getIndex(e);if(t>0&&t<this.status.nodes.length-1){const e=this.status.nodes[t-1],n=this.status.nodes[t+1];this.checkIntersection(e,n)}if(null===(h=this.log)||void 0===h||h.statusRemove(e.seg),this.status.remove(e),!a.primary){if(!a.seg.otherFill)throw new Error("otherFill is null");const e=a.seg.myFill;a.seg.myFill=a.seg.otherFill,a.seg.otherFill=e}d.push(a.seg)}this.events.removeHead()}return null===(a=this.log)||void 0===a||a.done(),d}}function r(e,t,n){const s=[];for(const o of e){const e=(o.myFill.above?8:0)+(o.myFill.below?4:0)+(o.otherFill&&o.otherFill.above?2:0)+(o.otherFill&&o.otherFill.below?1:0);if(0!==t[e]){const l=new i(o.start,o.end,null,n);l.myFill.above=1===t[e],l.myFill.below=2===t[e],s.push(l)}}return null==n||n.selected(s),s}class h{static union(e,t){return r(e,[0,2,1,0,2,2,0,0,1,0,1,0,0,0,0,0],t)}static intersect(e,t){return r(e,[0,0,0,0,0,2,0,2,0,0,1,1,0,2,1,0],t)}static difference(e,t){return r(e,[0,0,0,0,2,0,2,0,1,1,0,0,0,1,2,0],t)}static differenceRev(e,t){return r(e,[0,2,1,0,0,0,1,1,0,2,0,2,0,0,0,0],t)}static xor(e,t){return r(e,[0,2,1,0,2,0,0,1,1,0,0,2,0,1,2,0],t)}}function a(e,t,n){const s=[],i=[];for(const o of e){const l=o.start,r=o.end;if(t.pointsSame(l,r)){console.warn("PolyBool: Warning: Zero-length segment detected; your epsilon is probably too small or too large");continue}null==n||n.chainStart(o);const h={index:0,matches_head:!1,matches_pt1:!1},a={index:0,matches_head:!1,matches_pt1:!1};let d=h;function c(e,t,n){return d&&(d.index=e,d.matches_head=t,d.matches_pt1=n),d===h?(d=a,!1):(d=null,!0)}for(let f=0;f<s.length;f++){const b=s[f],w=b[0],S=b[b.length-1];if(t.pointsSame(w,l)){if(c(f,!0,!0))break}else if(t.pointsSame(w,r)){if(c(f,!0,!1))break}else if(t.pointsSame(S,l)){if(c(f,!1,!0))break}else if(t.pointsSame(S,r)&&c(f,!1,!1))break}if(d===h){s.push([l,r]),null==n||n.chainNew(l,r);continue}if(d===a){null==n||n.chainMatch(h.index);const y=h.index,E=h.matches_pt1?r:l,F=h.matches_head,x=s[y];let _=F?x[0]:x[x.length-1];const A=F?x[1]:x[x.length-2],B=F?x[x.length-1]:x[0],I=F?x[x.length-2]:x[1];if(t.pointsCollinear(A,_,E)&&(F?(null==n||n.chainRemoveHead(h.index,E),x.shift()):(null==n||n.chainRemoveTail(h.index,E),x.pop()),_=A),t.pointsSame(B,E)){s.splice(y,1),t.pointsCollinear(I,B,_)&&(F?(null==n||n.chainRemoveTail(h.index,_),x.pop()):(null==n||n.chainRemoveHead(h.index,_),x.shift())),null==n||n.chainClose(h.index),i.push(x);continue}F?(null==n||n.chainAddHead(h.index,E),x.unshift(E)):(null==n||n.chainAddTail(h.index,E),x.push(E));continue}function u(e){null==n||n.chainReverse(e),s[e].reverse()}function g(e,i){const o=s[e],l=s[i];let r=o[o.length-1];const h=o[o.length-2],a=l[0],d=l[1];t.pointsCollinear(h,r,a)&&(null==n||n.chainRemoveTail(e,r),o.pop(),r=h),t.pointsCollinear(r,a,d)&&(null==n||n.chainRemoveHead(i,a),l.shift()),null==n||n.chainJoin(e,i),s[e]=o.concat(l),s.splice(i,1)}const p=h.index,m=a.index;null==n||n.chainConnect(p,m);const v=s[p].length<s[m].length;h.matches_head?a.matches_head?v?(u(p),g(p,m)):(u(m),g(m,p)):g(m,p):a.matches_head?g(p,m):v?(u(p),g(m,p)):(u(m),g(p,m))}return i}class d{constructor(){this.list=[],this.nextSegmentId=0,this.curVert=NaN}push(e,t){this.list.push({type:e,data:JSON.parse(JSON.stringify(t))})}segmentId(){return this.nextSegmentId++}checkIntersection(e,t){this.push("check",{seg1:e,seg2:t})}segmentChop(e,t){this.push("div_seg",{seg:e,p:t}),this.push("chop",{seg:e,p:t})}statusRemove(e){this.push("pop_seg",{seg:e})}segmentUpdate(e){this.push("seg_update",{seg:e})}segmentNew(e,t){this.push("new_seg",{seg:e,primary:t})}tempStatus(e,t,n){this.push("temp_status",{seg:e,above:t,below:n})}rewind(e){this.push("rewind",{seg:e})}status(e,t,n){this.push("status",{seg:e,above:t,below:n})}vert(e){e!==this.curVert&&(this.push("vert",{x:e}),this.curVert=e)}selected(e){this.push("selected",{segs:e})}chainStart(e){this.push("chain_start",{seg:e})}chainRemoveHead(e,t){this.push("chain_rem_head",{index:e,p:t})}chainRemoveTail(e,t){this.push("chain_rem_tail",{index:e,p:t})}chainNew(e,t){this.push("chain_new",{p1:e,p2:t})}chainMatch(e){this.push("chain_match",{index:e})}chainClose(e){this.push("chain_close",{index:e})}chainAddHead(e,t){this.push("chain_add_head",{index:e,p:t})}chainAddTail(e,t){this.push("chain_add_tail",{index:e,p:t})}chainConnect(e,t){this.push("chain_con",{index1:e,index2:t})}chainReverse(e){this.push("chain_rev",{index:e})}chainJoin(e,t){this.push("chain_join",{index1:e,index2:t})}done(){this.push("done",null)}}class c{constructor(e){this.log=null,this.geo=e}buildLog(e){var t;return this.log=e?new d:null,null===(t=this.log)||void 0===t?void 0:t.list}segments(e){const t=new l(!0,this.geo,this.log);for(const n of e.regions)t.addRegion(n);return{segments:t.calculate(e.inverted,!1),inverted:e.inverted}}combine(e,t){const n=new l(!1,this.geo,this.log);for(const t of e.segments)n.addSegment(new i(t.start,t.end,t,this.log),!0);for(const e of t.segments)n.addSegment(new i(e.start,e.end,e,this.log),!1);return{combined:n.calculate(e.inverted,t.inverted),inverted1:e.inverted,inverted2:t.inverted}}selectUnion(e){return{segments:h.union(e.combined,this.log),inverted:e.inverted1||e.inverted2}}selectIntersect(e){return{segments:h.intersect(e.combined,this.log),inverted:e.inverted1&&e.inverted2}}selectDifference(e){return{segments:h.difference(e.combined,this.log),inverted:e.inverted1&&!e.inverted2}}selectDifferenceRev(e){return{segments:h.differenceRev(e.combined,this.log),inverted:!e.inverted1&&e.inverted2}}selectXor(e){return{segments:h.xor(e.combined,this.log),inverted:e.inverted1!==e.inverted2}}polygon(e){return{regions:a(e.segments,this.geo,this.log),inverted:e.inverted}}union(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),o=this.selectUnion(i);return this.polygon(o)}intersect(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),o=this.selectIntersect(i);return this.polygon(o)}difference(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),o=this.selectDifference(i);return this.polygon(o)}differenceRev(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),o=this.selectDifferenceRev(i);return this.polygon(o)}xor(e,t){const n=this.segments(e),s=this.segments(t),i=this.combine(n,s),o=this.selectXor(i);return this.polygon(o)}}const u=new c(new n);export{d as BuildLog,n as GeometryEpsilon,l as Intersecter,c as PolyBool,i as Segment,a as SegmentChainer,h as SegmentSelector,u as default};
